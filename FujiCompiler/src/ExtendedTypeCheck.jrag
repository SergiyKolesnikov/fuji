/* Extended Type Check
 * 2012-11-17
 * 
 * IMPORTANT: 
 * add jar de.ovgu.featureide.fm.core...jar (FM-Test 03)
 * add org.sat4j.core.jar (FM-Test 03)
 * to Fuji's build-path
 * 
 * for tests (TestSuite.java):
 * add org.eclipse.equinox.common...jar (FM-Test 03)
 * add jakarta.jar (FM-Test 03)
 * add guidsl.jar (FM-Test 03)
 * add org.sat4j.core.jar (FM-Test 03)
 * to Fujis's build-path
 * 
 * TODO: rewrite
 * This aspect extends the JastAddJ's type check:
 * (VarAccess.splTypeCheck())
 * - checks, if one feature tries to access a field of a second feature 
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * - when two or more features provide an implementation for a type and 
 *   all of them are optional, then it would be possible, that no implementation
 *   of the type is present. 
 * (MethodAccess.splTypeCheck())
 * - checks, if one feature tries to access a method of a second feature
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * - when two or more features provide an implementation for a type and 
 *   all of them are optional, then it would be possible, that no implementation
 *   of the type is present.
 * (TypeAccess.splTypeCheck())
 * - collect all type accesses and check, if all required types are present
 *   in at least one feature each
 *   - types, classes, interfaces, Generics, (try, catch, throw)
 *   - Cast, Constructor,
 *   - 4 types of inner classes (static, member, local, anonymous)
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.FeatureDependencies;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

import org.sat4j.specs.TimeoutException;

import fuji.TypeErrorInfo;

aspect ExtendedTypeCheck {

	/* the feature model */
	protected static FeatureModel ASTNode.featureModel;

	public FeatureModel ASTNode.getFeatureModel() {
		return featureModel;
	}

	public void ASTNode.setFeatureModel(FeatureModel model) {	
		featureModel = model;
	}

	/* collect all TypeAccesses in Map 
	 * format: 
	 * map: fromFeatureID, map: name of needed type, TypeErrorInfo
	 * (list of toFeatureIDs, that implement this type and source file name
	 * and line number of type accesses of this type) */
	protected static HashMap<Integer, HashMap<String, TypeErrorInfo>> 
	ASTNode.typeAccesses = 
	new HashMap<Integer, HashMap<String, TypeErrorInfo>>();

	/* for type accesses */
	protected ArrayList Program.errors = new ArrayList();

	/* for type accesses */
	protected ArrayList Program.warnings = new ArrayList();

	/* report a type error */
	/* correct line number and file name */
	public void ASTNode.typeError(String accessSourceInfo, String msg) {
		ASTNode node = this;
		while(node != null && !(node instanceof Program))
			node = node.getParent();
		Program pr = (Program)node;
		pr.errors.add(new Problem(accessSourceInfo, msg, 
				Problem.Severity.ERROR, Problem.Kind.SEMANTIC));
	}

	/* line numbers included in fileName */
	public Problem.Problem(String fileName, String message, Severity severity, Kind kind) {
		this(fileName, message);
		this.kind = kind;
		this.severity = severity;
	}

	/* (fromFeature ALWAYS toFeature) due to feature model */
	protected boolean ASTNode.always(FeatureDependencies dep, 
			Feature fromFeature, 
			Feature toFeature) {		  	  
		return dep.always(fromFeature).contains(toFeature);
	}

	/* (fromFeature NEVER toFeature) due to feature model */
	protected boolean ASTNode.never(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.never(fromFeature).contains(toFeature);
	}

	/* (fromFeature MAYBE toFeature) due to feature model */
	protected boolean ASTNode.maybe(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.maybe(fromFeature).contains(toFeature);
	}

	/* collect Type Errors */
	public void ASTNode.collectSplTypeErrors() {
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(featureModel.getConcreteFeatures());	
		/* for all fromFeatureIDs */
		for (int i : typeAccesses.keySet()) {
			Feature fromFeature = featureModel.getFeature(listFeatures
					.get(i).getName());
			/* Feature needs types */
			if (!(typeAccesses.get(i).isEmpty())) {			
				HashMap<String, TypeErrorInfo> typeNamesAndInfo = typeAccesses.get(i);					
				/* list qualified names of needed types ... */
				for(String td : typeNamesAndInfo.keySet()) {
					/* list of IDs of features, that implement this type */
					HashSet<Integer> toFeatureIDs = typeNamesAndInfo.get(td).getToFeatureIDs();				
					/* only one implementation */
					if(toFeatureIDs.size() == 1) {
						addSplErrors(i, toFeatureIDs.iterator().next(), "auf den Typ", td, true);
						/* more than one implementation */
					} else if(toFeatureIDs.size() > 1) {
						HashMap<Integer, String> mapDecls = new HashMap<Integer, String>();
						for(int toFeatureID : toFeatureIDs) {
							mapDecls.put(toFeatureID, td);
						}
						addSplErrors(i, toFeatureIDs, "auf den Typ", mapDecls, true);
					}
				}
			}
		}
	}

	/* copied from ErrorCheck.jrag and modified: added "spl" or "Spl" 
	 * in front of method names or in method names
	 * added: FeatureModel in ASTNode
	 * TODO: get sure, that the featureModel is properly initiated.
	 */

	/* */
	public void ASTNode.collectSplErrors() {
		splTypeCheck();
		for(int i = 0; i < getNumChild(); i++) {
			getChild(i).collectSplErrors();
		}
	}

	public void Program.splErrorCheck(FeatureModel model, Collection collection) {
		setFeatureModel(model);
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
			}
		}
		collectSplTypeErrors();
		collection.addAll(errors);
	}

	public void Program.splErrorCheck(FeatureModel model, Collection collection, Collection warn) {	
		setFeatureModel(model);
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
				warn.addAll(cu.warnings);
			}
		}
		collectSplTypeErrors();
		collection.addAll(errors);
		warn.addAll(warnings);
	}

	public void CompilationUnit.splErrorCheck(FeatureModel model, Collection collection) {
		setFeatureModel(model);
		collectSplErrors();
		collection.addAll(errors);
	}

	public void CompilationUnit.splErrorCheck(FeatureModel model, Collection err, Collection warn) {		
		setFeatureModel(model);
		collectSplErrors();
		err.addAll(errors);
		warn.addAll(warnings);
	}

	public boolean Program.splErrorCheck(FeatureModel model) {		
		Collection collection = new LinkedList();
		splErrorCheck(model, collection);
		if(collection.isEmpty()) {
			return false;
		}
		System.out.println("SPL Errors:");
		for(Iterator iter = collection.iterator(); iter.hasNext(); ) {
			String s = (String)iter.next();
			System.out.println(s);
		}
		return true;
	}

	/* /copy_&_modify */


	/* TODO: backup for type accesses: evaluate */

	/* Ausgabe von Fehlern bei nur einem Zielfeature */
	public void ASTNode.addSplErrors(int fromFeatureID,
			int toFeatureID, String targetStructure, String decl, boolean isTypeAccess) {
		FeatureModel model = getFeatureModel();

		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());

		/* beide Features vorhanden? */
		if(fromFeatureID != -1 && toFeatureID != -1) {

			/* Wird auf ein anderes Feature zugegriffen? */
			if (!(fromFeatureID == toFeatureID)) {
				/*
				 * Auf Reihenfolge Features aus dem FM zu
				 * Feature(-ID)s aus dem AST achten!
				 */				
				Feature fromFeature = model.getFeature(listFeatures
						.get(fromFeatureID).getName());
				Feature toFeature = model.getFeature(listFeatures
						.get(toFeatureID).getName());					 

				/* Ermittle Abhaengigkeiten aus dem FM */
				FeatureDependencies dep = new FeatureDependencies(model);	 

				/* kummulative Ausgabe der Quelldateinamen und Zeilennummern 
				 * fuer einen Typzugriff aus einem Feature */
				StringBuilder sbtei = new StringBuilder();
				if(isTypeAccess) {
					TypeErrorInfo tei = typeAccesses.get(fromFeatureID).get(decl);
					for(String s : tei.getAccessSourceInfo()) {
						sbtei.append(s);
						sbtei.append("\n");
					}
					sbtei.setLength(sbtei.length() - 1);
				}

				/* fromFeature und toFeature koennen nicht beide gleichzeitig
				 * in einer validen Auswahl vorkommen (never-Beziehung)
				 * -> Fehler
				 */
				if(never(dep, fromFeature, toFeature)) {
					StringBuilder sb = new StringBuilder();
					sb.append("never-Beziehung:");
					sb.append("\nFeature ");
					sb.append(fromFeature.getName());
					sb.append(" greift ");
					sb.append(targetStructure);
					sb.append("\n  ");
					sb.append(decl);
					sb.append("\ndes Features ");
					sb.append(toFeature.getName());
					sb.append(" zu.\nDie Features ");
					sb.append(fromFeature.getName());
					sb.append(" und ");
					sb.append(toFeature.getName());
					sb.append(" koennen aber ");
					sb.append("nicht beide gleichzeitig in einer validen ");
					sb.append("Auswahl vorkommen.\n");
					if(isTypeAccess) {						
						typeError(sbtei.toString(), sb.toString());
					} else {
						error(sb.toString());
					}
				}

				/* toFeature kann, muss aber nicht in einer validen Auswahl
				 * vorkommen (maybe-Beziehung) -> moegliche Fehlerquelle
				 */
				if(maybe(dep, fromFeature, toFeature)) {				
					StringBuilder sb = new StringBuilder();
					sb.append("maybe-Beziehung:");
					sb.append("\nFeature ");
					sb.append(fromFeature.getName());
					sb.append(" greift ");
					sb.append(targetStructure);
					sb.append("\n  ");
					sb.append(decl);
					sb.append("\ndes Features ");
					sb.append(toFeature.getName());
					sb.append(" zu.\n");
					sb.append("Das Ziel-Feature ");
					sb.append(toFeature.getName());
					sb.append(" ist aber nicht in jeder ");
					sb.append("moeglichen validen Auswahl vorhanden.\n");
					if(isTypeAccess) {
						typeError(sbtei.toString(), sb.toString());
					} else {
						error(sb.toString());
					}
				}
			}
		}		
	}

	/* Ausgabe von Fehlern bei mehreren Zielfeatures */
	public void ASTNode.addSplErrors(int fromFeatureID,
			HashSet<Integer> toFeatureIDs, String targetStructure, 
			HashMap<Integer, String> mapDecls, boolean isTypeAccess) {
		FeatureModel model = getFeatureModel();

		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());
		Feature fromFeature = model.getFeature(listFeatures
				.get(fromFeatureID).getName());

		/* Liste einer Menge von Zielfeatures */
		ArrayList<Set<Feature>> toFeaturesList = new ArrayList<Set<Feature>>();
		for (int toFeatureID : toFeatureIDs) {
			Feature toFeature = model.getFeature(listFeatures.get(toFeatureID).getName());
			HashSet<Feature> toFeatureSet = new HashSet<Feature>();
			toFeatureSet.add(toFeature);
			toFeaturesList.add(toFeatureSet);
		}

		/* for TypeAccess: list all source files and line numbers,
		 * where a TypeAccess to a specific type takes place */
		StringBuilder sbtei = new StringBuilder();
		if(isTypeAccess) {
			TypeErrorInfo tei = typeAccesses.get(fromFeatureID).get(mapDecls.get(mapDecls.keySet().iterator().next()));
			for(String s : tei.getAccessSourceInfo()) {
				sbtei.append(s);
				sbtei.append("\n");
			}
			sbtei.setLength(sbtei.length() - 1);
		}

		HashSet<Feature> accessingFeature = new HashSet<Feature>();
		accessingFeature.add(fromFeature);

		try {
			/* alle Features optional, aufrufendes Feature ist gesetzt */
			if (model.mayBeMissing(accessingFeature, toFeaturesList)) {	
				StringBuilder sb = new StringBuilder();
				sb.append(toFeatureIDs.size());
				sb.append(" optionale Ziele ");
				sb.append("(es kann eine valide Auswahl geben, "
						+ "in der alle diese Ziele nicht vorhanden sind):\n");
				sb.append("Feature ");
				sb.append(fromFeature.getName());
				sb.append(" zielt ");
				sb.append(targetStructure);
				sb.append(" folgender Features:\n");
				for (int toFeatureID : toFeatureIDs) {
					sb.append(model.getFeature(listFeatures.get(toFeatureID).getName()).getName());
					sb.append(":\t");
					String decl = mapDecls.get(toFeatureID);
					sb.append(decl);
					sb.append("\n");
				}
				if(isTypeAccess) {
					typeError(sbtei.toString(), sb.toString());
				} else {
					error(sb.toString());
				}
			}				
		} catch (TimeoutException e) {
			e.printStackTrace();
		}
	}

	/* TODO: /backup */
	
	public void ASTNode.addSplErrors(int fromFeatureID, SimpleSet decls,
			String targetStructure, boolean isTypeAccess, TypeDecl sourceHostType,
			boolean secondRoundDone) {
		FeatureModel model = getFeatureModel();
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/*
		 * TODO: werden hierdurch ALLE benoetigten Features in der richtigen
		 * REIHENFOLGE eingelesen?
		 */
		listFeatures.addAll(model.getConcreteFeatures());
		if (decls.size() == 1) {
			BodyDecl decl = (BodyDecl) decls.iterator().next();
			int toFeatureID = decl.featureID();
			TypeDecl targetHostType = decl.hostType();
			String declString = decl.toString();
			String declFirstLine = (declString.indexOf("\n") == -1 ? declString
					: declString.substring(0, declString.indexOf("\n")) + " ... }");

			/* beide Features vorhanden? */
			if (fromFeatureID != -1 && toFeatureID != -1) {
				/* Wird auf ein anderes Feature zugegriffen? */
				if (!(fromFeatureID == toFeatureID)) {
					/*
					 * Auf Reihenfolge Features aus dem FM zu Feature(-ID)s aus dem AST
					 * achten!
					 */
					Feature fromFeature = model.getFeature(listFeatures
							.get(fromFeatureID).getName());
					Feature toFeature = model.getFeature(listFeatures.get(toFeatureID)
							.getName());
					/* Ermittle Abhaengigkeiten aus dem FM */
					FeatureDependencies dep = new FeatureDependencies(model);
					/*
					 * kummulative Ausgabe der Quelldateinamen und Zeilennummern fuer
					 * einen Typzugriff aus einem Feature
					 */
					StringBuilder sbtei = new StringBuilder();
					if (isTypeAccess) {
						TypeErrorInfo tei = typeAccesses.get(fromFeatureID).get(
								declFirstLine);
						for (String s : tei.getAccessSourceInfo()) {
							sbtei.append(s);
							sbtei.append("\n");
						}
						sbtei.setLength(sbtei.length() - 1);
					}
					/*
					 * fromFeature und toFeature koennen nicht beide gleichzeitig in einer
					 * validen Auswahl vorkommen (never-Beziehung) -> Fehler
					 */
					if (never(dep, fromFeature, toFeature)) {
						StringBuilder sb = new StringBuilder();
						sb.append("never-Beziehung:");
						sb.append("\nFeature ");
						sb.append(fromFeature.getName());
						sb.append(" greift ");
						sb.append(targetStructure);
						sb.append("\n  ");
						sb.append(declFirstLine);
						sb.append("\ndes Features ");
						sb.append(toFeature.getName());
						sb.append(" zu.\nDie Features ");
						sb.append(fromFeature.getName());
						sb.append(" und ");
						sb.append(toFeature.getName());
						sb.append(" koennen aber ");
						sb.append("nicht beide gleichzeitig in einer validen ");
						sb.append("Auswahl vorkommen.\n");
						if (isTypeAccess) {
							typeError(sbtei.toString(), sb.toString());
						} else {
							error(sb.toString());
						}
					}
					/*
					 * toFeature kann, muss aber nicht in einer validen Auswahl vorkommen
					 * (maybe-Beziehung) -> moegliche Fehlerquelle
					 */
					if (maybe(dep, fromFeature, toFeature)) {
						StringBuilder sb = new StringBuilder();
						sb.append("maybe-Beziehung:");
						sb.append("\nFeature ");
						sb.append(fromFeature.getName());
						sb.append(" greift ");
						sb.append(targetStructure);
						sb.append("\n  ");
						sb.append(declFirstLine);
						sb.append("\ndes Features ");
						sb.append(toFeature.getName());
						sb.append(" zu.\n");
						sb.append("Das Ziel-Feature ");
						sb.append(toFeature.getName());
						sb.append(" ist aber nicht in jeder ");
						sb.append("moeglichen validen Auswahl vorhanden.\n");
						if (isTypeAccess) {
							typeError(sbtei.toString(), sb.toString());
						} else {
							error(sb.toString());
						}
					}
					if (!(secondRoundDone)) {
						/* second Round */

						/*
						 * bekannt: - eindeutiges Ziel (d.h. eine toFeatureID), d.h. nur
						 * eine Implementierung des Typs, im dem sich das Ziel befindet -
						 * Quell- und Ziel-Feature sind beide vorhanden - Quell- und
						 * Ziel-Feature sind unterschiedlich
						 */

						/*
						 * in jeweiliger Liste (extends, implements, throws) herausfinden,
						 * in welchem Feature Information fehlt (unter der Bedingung, dass
						 * in den anderen Features keine widerspruechliche Information
						 * vorhanden ist) maybe- oder never-Beziehung dieser Features zu/m
						 * informations- tragenden Feature(s) herausfinden -> Fehlermeldung,
						 * wenn die Information nicht in allen validen Produkten vorhanden
						 * sein kann (wenn nicht mindestens ein informationstragendes
						 * Feature in always-Beziehung zu mindestens einem Feature ohne
						 * diese Information steht) - extends (fuer Klassen und Interfaces)
						 * - implements (nur fuer Klassen) qualified name, gleichbenannte
						 * Klassen in verschiedenen Verzeichnissen? ermittle die Liste der
						 * Features, die an dieser Klasse beteiligt sind: (alternativ:
						 * mittels SPLStructure getRoleGroups)
						 */

						/*
						 * ansonsten: teste, ob extends-, implements- oder throws-
						 * Information nicht in dieser Klasse des Quellfeatures, dafuer aber
						 * nur in dieser Klasse eines Zielfeatures steht, das mit dieser
						 * Klasse des Quellfeatures in maybe-, never-, bzw. bei mehreren
						 * Ziele in mayBeMissing-Beziehung steht
						 */

						/*
						 * Zugriff kommt aus einer Klasse: pruefe auf extends und implements
						 */
						if (sourceHostType instanceof ClassDecl) {
							ClassDecl sc = (ClassDecl) sourceHostType;
							/*
							 * ermittle, welche Features alle zu dieser Klasse beigetragen
							 * haben
							 */
							HashSet<Integer> allFeatures = new HashSet<Integer>();
							for (BodyDecl bd : sc.getBodyDecls()) {
								allFeatures.add(bd.featureID());
							}
							/* Zugriff geht auf ein Element in einer Klasse */
							if (targetHostType instanceof ClassDecl) {
								/* extends-Info */
								/*
								 * ermittle alle Features, in denen extends-Information mit
								 * diesem targetHostType vorhanden ist
								 */
								HashSet<Integer> featuresWithExtendInfo = new HashSet<Integer>();
								if (!(sc.getPreservedSuperClassAccess().isEmpty())) {
									for (Access ac : sc.getPreservedSuperClassAccess()) {
										/* wenn das der gesuchte Typ ist */
										if (ac.type().equals(targetHostType)) {
											/*
											 * speichere featureID des Features, das diese
											 * extends-Information enthaelt
											 */
											featuresWithExtendInfo.add(ac.featureID());
										}
									}
								}
								if (sc.hasSuperClassAccess()) {
									/* wenn das der gesuchte Typ ist */
									if (sc.getSuperClassAccess().type().equals(targetHostType)) {
										featuresWithExtendInfo.add(sc.getSuperClassAccess()
												.featureID());
									}
								}
								/*
								 * wenn ueberhaupt extends-Info mit diesem targetType vorhanden
								 * war:
								 */
								if (!(featuresWithExtendInfo.isEmpty())) {
									/*
									 * fehlt in fromFeature die extends-Information mit diesem
									 * targetType?
									 */
									if (!(featuresWithExtendInfo.contains(fromFeatureID))) {
										/* TODO: Ausgabe bei mehreren Zielen ueberpruefen */
										addSplErrors(fromFeatureID, decls,
												"mittels nicht immer vorhandener extends-Information "
														+ targetStructure + " im Typ "
														+ targetHostType.name().toString(), false,
												sourceHostType, true);
									}
								}
							}
							/* Zugriff geht auf ein Element aus einem Interface */
							if (targetHostType instanceof InterfaceDecl) {
								/* implements-Info */
								/*
								 * ermittle alle Features, in denen die implements-Info mit
								 * diesem targetHostType vorhanden ist
								 */
								HashSet<Integer> featuresWithImplementInfo = new HashSet<Integer>();
								if (sc.getNumImplements() != 0) {
									for (Access ac : sc.getImplementsList()) {
										if (ac.type().equals(targetHostType)) {
											featuresWithImplementInfo.add(ac.featureID());
										}
									}
								}
								/* wenn ueberhaupt Features diesen targetHostType implementieren */
								if (!(featuresWithImplementInfo.isEmpty())) {
									/* fehlt im fromFeature diese implements-Information? */
									if (!(featuresWithImplementInfo.contains(fromFeature))) {
										addSplErrors(fromFeatureID, decls,
												"mittels nicht immer vorhandener implements-Information "
														+ targetStructure + " im Typ "
														+ targetHostType.name().toString(), false,
												sourceHostType, true);
									}
								}
							}
						}
						/* Zugriff kommt aus einem Interface: pruefe auf extends */
						if (sourceHostType instanceof InterfaceDecl) {
							if (targetHostType instanceof InterfaceDecl) {
								InterfaceDecl si = (InterfaceDecl) sourceHostType;
								/*
								 * ermittle, welche Features alle zu diesem Interface
								 * beigetragen haben
								 */
								HashSet<Integer> allFeatures = new HashSet<Integer>();
								for (BodyDecl bd : si.getBodyDecls()) {
									allFeatures.add(bd.featureID());
								}

								/* extends-Info */
								/*
								 * ermittle alle Features, in denen extends-Information mit
								 * diesem targetHostType vorhanden ist
								 */
								HashSet<Integer> featuresWithExtendInfo = new HashSet<Integer>();
								if (si.getNumSuperInterfaceId() != 0) {
									for (Access ac : si.getSuperInterfaceIdList()) {
										/* wenn das der gesuchte Typ ist */
										if (ac.type().equals(targetHostType)) {
											/*
											 * speichere featureID des Features, das diese
											 * extends-Information enthaelt
											 */
											featuresWithExtendInfo.add(ac.featureID());
										}
									}
								}
								/*
								 * wenn ueberhaupt extends-Info mit diesem targetType vorhanden
								 * war:
								 */
								if (!(featuresWithExtendInfo.isEmpty())) {
									/*
									 * fehlt in fromFeature die extends-Information mit diesem
									 * targetType?
									 */
									if (!(featuresWithExtendInfo.contains(fromFeatureID))) {
										addSplErrors(fromFeatureID, decls,
												"mittels nicht immer vorhandener extends-Information "
														+ targetStructure + " im Typ "
														+ targetHostType.name().toString(), false,
												sourceHostType, true);
									}
								}
							}
						}
					}
				}
			}
		} else if (decls.size() > 1) {
			/* TODO: add secondRound */
			HashSet<Integer> toFeatureIDs = new HashSet<Integer>();
			HashMap<Integer, String> mapDecls = new HashMap<Integer, String>();
			HashSet<TypeDecl> targetTypes = new HashSet<TypeDecl>();
			for(Iterator iter = decls.iterator(); iter.hasNext(); ){
				BodyDecl var = (BodyDecl) iter.next();
				toFeatureIDs.add(var.featureID());
				String declString = var.toString();
				String declFirstLine = ( declString.indexOf("\n") == -1 ? declString 
						: declString.substring(0, declString.indexOf("\n")) + " ... }" );
				mapDecls.put(var.featureID(), declFirstLine);
				targetTypes.add(var.hostType());
			}
			
			Feature fromFeature = model.getFeature(listFeatures.get(fromFeatureID)
					.getName());
			/* Liste einer Menge von Zielfeatures */
			ArrayList<Set<Feature>> toFeaturesList = new ArrayList<Set<Feature>>();
			for (int toFeatureID : toFeatureIDs) {
				Feature toFeature = model.getFeature(listFeatures.get(toFeatureID)
						.getName());
				HashSet<Feature> toFeatureSet = new HashSet<Feature>();
				toFeatureSet.add(toFeature);
				toFeaturesList.add(toFeatureSet);
			}
			/*
			 * for TypeAccess: list all source files and line numbers, where a
			 * TypeAccess to a specific type takes place
			 */
			StringBuilder sbtei = new StringBuilder();
			if (isTypeAccess) {
				TypeErrorInfo tei = typeAccesses.get(fromFeatureID).get(
						mapDecls.get(mapDecls.keySet().iterator().next()));
				for (String s : tei.getAccessSourceInfo()) {
					sbtei.append(s);
					sbtei.append("\n");
				}
				sbtei.setLength(sbtei.length() - 1);
			}
			HashSet<Feature> accessingFeature = new HashSet<Feature>();
			accessingFeature.add(fromFeature);
			try {
				/* alle Features optional, aufrufendes Feature ist gesetzt */
				if (model.mayBeMissing(accessingFeature, toFeaturesList)) {
					StringBuilder sb = new StringBuilder();
					sb.append(toFeatureIDs.size());
					sb.append(" optionale Ziele ");
					sb.append("(es kann eine valide Auswahl geben, "
							+ "in der alle diese Ziele nicht vorhanden sind):\n");
					sb.append("Feature ");
					sb.append(fromFeature.getName());
					sb.append(" zielt ");
					sb.append(targetStructure);
					sb.append(" folgender Features:\n");
					for (int toFeatureID : toFeatureIDs) {
						sb.append(model.getFeature(listFeatures.get(toFeatureID).getName())
								.getName());
						sb.append(":\t");
						String decl = mapDecls.get(toFeatureID);
						sb.append(decl);
						sb.append("\n");
					}
					if (isTypeAccess) {
						typeError(sbtei.toString(), sb.toString());
					} else {
						error(sb.toString());
					}
				}
			} catch (TimeoutException e) {
				e.printStackTrace();
			}
		}
	}

	public void ASTNode.splTypeCheck() { }

	public void VarAccess.splTypeCheck() {
		/* Ist der Variablenzugriff ein Feldzugriff? */
		if (isFieldAccess()) {
				addSplErrors(featureID(), decls(), "auf das Feld", false, hostType(), false);
		}    
	}

	public void MethodAccess.splTypeCheck() {
		ArrayList<MethodDecl> methodDecls = new ArrayList<MethodDecl>();
		/*
		 * original-Check: Teste, ob eine Methode "original" heiszt, dann sollte in
		 * diesem Typ (in diesem oder einem anderem Feature) eine Methode mit
		 * gleicher Signatur wie die Aufrufumgebung existieren
		 */
		/*
		 * Methodenaufruf original gefunden, in einem anderen Feature muss im
		 * gleichen Typ eine Methode mit gleicher Signatur wir die Methode des
		 * Aufrufkontexts enthalten sein und das Feature laut Feature-Modell
		 * verfuegbar sein
		 */
		if (name().equals("original")) {
			/* in welcher Methode ist dieser original-Aufruf enthalten? */
			String context = ((MethodDecl) enclosingBodyDecl()).signature();
			/*
			 * ermittle im Typ alle Methoden mit gleicher Signatur, die aus einem
			 * anderen Feature stammen
			 */
			for (BodyDecl bd : hostType().getBodyDecls()) {
				if (bd instanceof MethodDecl) {
					MethodDecl md = (MethodDecl) bd;
					if (md.signature().equals(context) && (md.featureID() != featureID())) {
						methodDecls.add(md);
					}
				}
			}
			StringBuffer s = new StringBuffer();
			s.append("mittels des original-Aufrufs\n  ");
			s.append(name());
			s.append("(");
			for (int i = 0; i < getNumArg(); i++) {
				if (i != 0) {
					s.append(", ");
				}
				s.append(getArg(i).type().typeName());
			}
			s.append(")");
			s.append(" in der Methode " + context + " des Typs " + methodHost());
			s.append(" auf die Methode");
			addSplErrors(featureID(), new SimpleSet.SimpleSetImpl(methodDecls),
					s.toString(), false, hostType(), false);
		} else {
			/* ermittle im Typ alle Methoden mit gleicher Signatur */
			for (BodyDecl bd : decl().hostType().getBodyDecls()) {
				if (bd instanceof MethodDecl) {
					if (((MethodDecl) bd).signature().equals(decl().signature())) {
						methodDecls.add((MethodDecl) bd);
					}
				}
			}
			addSplErrors(featureID(), new SimpleSet.SimpleSetImpl(methodDecls),
					"auf die Methode", false, hostType(), false);
		}
	}

	public void TypeAccess.splTypeCheck() {				
		/* given for this TypeAccess: fromFeatureID, type name */
		/* collect all TypeAccesses: source feature, type, target feature(s),
		 * source file(s), line number(s) */		
		int fromFeatureID = featureID();
		/* ignore importDecl */
		if(isRaw()) {
			HashMap<String, TypeErrorInfo> typeNamesAndInfo = typeAccesses.get(fromFeatureID);
			if(typeNamesAndInfo == null) {
				typeNamesAndInfo = new HashMap<String, TypeErrorInfo>();
			}
			/* <package name (default: "(default package)")>.<type name> */
			String qualifiedName = ( decl().hostType().packageName() != "" 
					? decl().hostType().packageName() 
							: "(default package)" ) 
							+ "." 
							+ decl().hostType().name();

			TypeErrorInfo tei = typeNamesAndInfo.get(qualifiedName);
			if(tei == null) {
				tei = new TypeErrorInfo(new HashSet<Integer>(), new HashSet<String>());
			}
			HashSet<Integer> toFeatureIDs = tei.getToFeatureIDs();
			/* find all constructors of this type to get sure that the type
			 * is reachable, but this is not enough: also get sure that
			 * the right constructor is reachable 
			 * --> ClassInstanceExpr.splTypeCheck() */
			ArrayList<ConstructorDecl> constructorDecls = new ArrayList<ConstructorDecl>();
			for(BodyDecl bd : decl().hostType().getBodyDecls()) {
				if (bd instanceof ConstructorDecl) {
					constructorDecls.add((ConstructorDecl) bd);
				}
			}
			/* collect all featureIDs of features, that implement this type,
			 * i.e. that have a constructor for this type */
			for(Iterator iter = constructorDecls.iterator(); iter.hasNext(); ){
				ConstructorDecl var = (ConstructorDecl) iter.next();
				toFeatureIDs.add(var.featureID());
			}
			/* remember source file and line number of type access */
			tei.getAccessSourceInfo().add(sourceFile() + ":" + lineNumber());

			/* default-Typen nicht sammeln */
			if (!(decl().hostType().featureID() == -1)) {
				typeNamesAndInfo.put(qualifiedName, tei);
			}		
			typeAccesses.put(fromFeatureID, typeNamesAndInfo);
		}
	}

	public void ClassInstanceExpr.splTypeCheck() {
		ArrayList<ConstructorDecl> constructorDecls = new ArrayList<ConstructorDecl>();
		/* ermittle im Typ alle Konstruktoren mit gleicher Signatur */
		for (BodyDecl bd : decl().hostType().getBodyDecls()) {
			if (bd instanceof ConstructorDecl) {
				if (((ConstructorDecl) bd).signature().equals(decl().signature())) {
					constructorDecls.add((ConstructorDecl) bd);
				}
			}
		}
		addSplErrors(featureID(), new SimpleSet.SimpleSetImpl(constructorDecls),
				"auf den Konstruktor", false, hostType(), false);
	}
}