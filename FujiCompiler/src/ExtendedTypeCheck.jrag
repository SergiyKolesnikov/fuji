/* Extended Type Check
 * 2012-04-14
 * 
 * IMPORTANT: 
 * add jar de.ovgu.featureide.fm.core...jar (FM-Test 03)
 * to Fuji's build-path
 * 
 * for tests (TestSuite.java):
 * add org.eclipse.equinox.common...jar (FM-Test 03)
 * add jakarta.jar (FM-Test 03)
 * add guidsl.jar (FM-Test 03)
 * add org.sat4j.core.jar (FM-Test 03)
 * to Fujis's build-path
 * 
 * This aspect extends the JastAddJ's type check:
 * (VarAccess.splTypeCheck())
 * - checks, if one feature tries to access a field of a second feature 
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * - when two or more features provide an implementation for a type and 
 *   all of them are optional, then it would be possible, that no implementation
 *   of the type is present. 
 * (MethodAccess.splTypeCheck())
 * - checks, if one feature tries to access a method of a second feature
 *   that is optional -> error, if not explicitly stated as a constraint
 *   in the feature model
 * - same for two mutual exclusive fields
 * - when two or more features provide an implementation for a type and 
 *   all of them are optional, then it would be possible, that no implementation
 *   of the type is present.
 * (TypeAccess.splTypeCheck())
 * - collect all type accesses and check, if all required types are present
 *   in at least one feature each
 *   - types, classes, interfaces, Generics, (try, catch, throw)
 *   - Cast, Constructor,
 *   - 4 types of inner classes (static, member, local, anonymous)
 */

import de.ovgu.featureide.fm.core.FeatureModel;
import de.ovgu.featureide.fm.core.Feature;
import de.ovgu.featureide.fm.core.FeatureDependencies;
import de.ovgu.featureide.fm.core.io.guidsl.GuidslReader;
import de.ovgu.featureide.fm.core.io.UnsupportedModelException;

import org.sat4j.specs.TimeoutException;

aspect ExtendedTypeCheck {

	/* hold the feature model */
	protected static FeatureModel ASTNode.featureModel;

	public FeatureModel ASTNode.getFeatureModel() {
		return featureModel;
	}

	public void ASTNode.setFeatureModel(FeatureModel model) {	
		featureModel = model;
	}
	
	/* collect TypeAccesses in Map 
	 * format: map: fromFeatureID, map: name of needed type and list 
	 * of toFeatureIDs, that implement this type */
	protected static HashMap<Integer, HashMap<String, ArrayList<Integer>>> 
	    ASTNode.typeAccesses = 
	    new HashMap<Integer, HashMap<String, ArrayList<Integer>>>();
	
	protected ArrayList Program.errors = new ArrayList();
	
	protected ArrayList Program.warnings = new ArrayList();
	
	public void ASTNode.typeError(String s) {
		ASTNode node = this;
		while(node != null && !(node instanceof Program))
			node = node.getParent();
		Program pr = (Program)node;
		if(getNumChild() == 0 && getStart() != 0 && getEnd() != 0) {  
			int line = getLine(getStart());
			int column = getColumn(getStart());
			int endLine = getLine(getEnd());
			int endColumn = getColumn(getEnd());
			pr.errors.add(new Problem(sourceFile(), s, line, column, endLine, endColumn, Problem.Severity.ERROR, Problem.Kind.SEMANTIC));
		}
		else
			pr.errors.add(new Problem(sourceFile(), s, lineNumber(), Problem.Severity.ERROR, Problem.Kind.SEMANTIC));
	}

	/* (fromFeature ALWAYS toFeature) due to feature model */
	protected boolean ASTNode.always(FeatureDependencies dep, 
			Feature fromFeature, 
			Feature toFeature) {		  	  
		return dep.always(fromFeature).contains(toFeature);
	}

	/* (fromFeature NEVER toFeature) due to feature model */
	protected boolean ASTNode.never(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.never(fromFeature).contains(toFeature);
	}

	/* (fromFeature MAYBE toFeature) due to feature model */
	protected boolean ASTNode.maybe(FeatureDependencies dep,
			Feature fromFeature,
			Feature toFeature) {
		return dep.maybe(fromFeature).contains(toFeature);
	}
	
	/* collect Type Errors */
	public void ASTNode.collectSplTypeErrors() {
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(featureModel.getConcreteFeatures());
		
		/* for all fromFeatureIDs */
		for (int i : typeAccesses.keySet()) {
			Feature fromFeature = featureModel.getFeature(listFeatures
					.get(i).getName());
			/* needs types */
			if (!(typeAccesses.get(i).isEmpty())) {			
				HashMap<String, ArrayList<Integer>> typeDeclFeatures = typeAccesses.get(i);
							
				/* list names of needed types ... */
				for(String td : typeDeclFeatures.keySet()) {
					Feature toFeature;
					ArrayList<Integer> toFeatureIDs = typeDeclFeatures.get(td);
					
					/* only one implementation */
					if(toFeatureIDs.size() == 1) {
						addSplErrors(i, toFeatureIDs.get(0), "den Typ", td, true);
				    /* more than one implementation*/
					} else {
						HashMap<Integer, String> mapDecls = new HashMap<Integer, String>();
						for(int toFeatureID : toFeatureIDs) {
							mapDecls.put(toFeatureID, td);
						}
						addSplErrors(i, toFeatureIDs, "den Typ", mapDecls, true);
					}
				}
			}
		}
	}

	
	/* copied from ErrorCheck.jrag and modified: added "spl" or "Spl" 
	 * in front of method names or in method names
	 * added: FeatureModel in ASTNode
	 * TODO: get sure, that the featureModel is properly initiated.
	 */

	/* */
	public void ASTNode.collectSplErrors() {
		splTypeCheck();
		for(int i = 0; i < getNumChild(); i++) {
			getChild(i).collectSplErrors();
		}
	}
	
	/* DEBUG */
	public static String ASTNode.getTypeAccessesString() {
		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(featureModel.getConcreteFeatures());
		
		StringBuilder sb = new StringBuilder();
		
		sb.append("Feature (\"/\" = braucht) Typ" +
				"\t->\timplementiert in Feature(s)\n");
		
		/* for all fromFeatureIDs */
		for (int i : typeAccesses.keySet()) {
			Feature fromFeature = featureModel.getFeature(listFeatures
					.get(i).getName());
			/* needs types */
			if (!(typeAccesses.get(i).isEmpty())) {			
				HashMap<String, ArrayList<Integer>> typeDeclFeatures = typeAccesses.get(i);
				/* list names of needed types ... */
				for(String td : typeDeclFeatures.keySet()) {
					sb.append(fromFeature.getName());
					sb.append("\t / \t" + td);
					sb.append("\t->\t[ ");
					Feature toFeature;
					ArrayList<Integer> toFeatureIDs = typeDeclFeatures.get(td);
					/* ... and the features, that implement this type */
					for (int j : toFeatureIDs) {
						toFeature = featureModel.getFeature(listFeatures.get(j).getName());
						sb.append(toFeature.getName() + ", ");
					}
					sb.append("]\n");
				}
			}
		}
		return sb.toString();
	}

	public void Program.splErrorCheck(FeatureModel model, Collection collection) {
		setFeatureModel(model);
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
			}
		}
		collectSplTypeErrors();
		collection.addAll(errors);
	}

	public void Program.splErrorCheck(FeatureModel model, Collection collection, Collection warn) {	
		setFeatureModel(model);
		for(Iterator iter = compilationUnitIterator(); iter.hasNext(); ) {
			CompilationUnit cu = (CompilationUnit)iter.next();
			if(cu.fromSource()) {
				cu.collectSplErrors();
				collection.addAll(cu.errors);
				warn.addAll(cu.warnings);
			}
		}
		collectSplTypeErrors();
		collection.addAll(errors);
		warn.addAll(warnings);
	}

	public void CompilationUnit.splErrorCheck(FeatureModel model, Collection collection) {
		setFeatureModel(model);
		collectSplErrors();
		collection.addAll(errors);
	}

	public void CompilationUnit.splErrorCheck(FeatureModel model, Collection err, Collection warn) {		
		setFeatureModel(model);
		collectSplErrors();
		err.addAll(errors);
		warn.addAll(warnings);
	}

	public boolean Program.splErrorCheck(FeatureModel model) {		
		Collection collection = new LinkedList();
		splErrorCheck(model, collection);
		if(collection.isEmpty()) {
			return false;
		}
		System.out.println("SPL Errors:");
		for(Iterator iter = collection.iterator(); iter.hasNext(); ) {
			String s = (String)iter.next();
			System.out.println(s);
		}
		return true;
	}

	/* /copy_&_modify */

	/* Ausgabe von Fehlern bei nur einem Zielfeature */
	public void ASTNode.addSplErrors(int fromFeatureID,
			int toFeatureID, String targetStructure, String decl, boolean isTypeAccess) {
		FeatureModel model = getFeatureModel();

		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());

		/* beide Features vorhanden? */
		if(fromFeatureID != -1 && toFeatureID != -1) {

			/* Wird auf ein anderes Feature zugegriffen? */
			if (!(fromFeatureID == toFeatureID)) {
				/*
				 * Auf Reihenfolge Features aus dem FM zu
				 * Feature(-ID)s aus dem AST achten!
				 */				
				Feature fromFeature = model.getFeature(listFeatures
						.get(fromFeatureID).getName());
				Feature toFeature = model.getFeature(listFeatures
						.get(toFeatureID).getName());					 

				/* Ermittle Abhaengigkeiten aus dem FM */
				FeatureDependencies dep = new FeatureDependencies(model);	 

				/* Ausgabe nur der ersten Zeile der Zielstruktur */
				String declFirstLine = 
						( decl.indexOf("\n") == -1 ? 
								decl : decl.substring(0, decl.indexOf("\n")) 
								       + " ... }");

				/* fromFeature und toFeature koennen nicht beide gleichzeitig
				 * in einer validen Auswahl vorkommen -> Fehler
				 */
				if(never(dep, fromFeature, toFeature)) {
					StringBuilder sb = new StringBuilder();
					sb.append("never-Beziehung:");
					sb.append("\n    Feature ");
					sb.append(fromFeature.getName());
					sb.append(" greift auf ");
					sb.append(targetStructure);
					sb.append("\n      ");
					sb.append(declFirstLine);
					sb.append("\n    des Features ");
					sb.append(toFeature.getName());
					sb.append(" zu.\n    ");
					sb.append(fromFeature.getName());
					sb.append(" und ");
					sb.append(toFeature.getName());
					sb.append(" kšnnen aber ");
					sb.append("nicht beide gleichzeitig in einer validen ");
					sb.append("Auswahl vorkommen.\n");
					if(isTypeAccess) {
						typeError(sb.toString());
					} else {
						error(sb.toString());
					}
				}

				/* toFeature kann, muss aber nicht in einer validen Auswahl
				 * vorkommen -> moegliche Fehlerquelle
				 */
				if(maybe(dep, fromFeature, toFeature)) {				
					StringBuilder sb = new StringBuilder();
					sb.append("maybe-Beziehung:");
					sb.append("\n    Feature ");
					sb.append(fromFeature.getName());
					sb.append(" greift auf ");
					sb.append(targetStructure);
					sb.append("\n      ");
					sb.append(declFirstLine);
					sb.append("\n    des Features ");
					sb.append(toFeature.getName());
					sb.append(" zu.\n");
					sb.append("Das Ziel-Feature ist aber nicht in jeder ");
					sb.append("mšglichen validen Auswahl vorhanden.\n");
					if(isTypeAccess) {
						typeError(sb.toString());
					} else {
						error(sb.toString());
					}
				}
			}
		}		
	}

	/* Ausgabe von Fehlern bei mehreren Zielfeatures */
	public void ASTNode.addSplErrors(int fromFeatureID,
			ArrayList<Integer> toFeatureIDs, String targetStructure, 
			HashMap<Integer, String> mapDecls, boolean isTypeAccess) {
		FeatureModel model = getFeatureModel();

		/* get features */
		ArrayList<Feature> listFeatures = new ArrayList<Feature>();
		/* TODO: werden hierdurch ALLE benoetigten Features in der 
		 * richtigen REIHENFOLGE eingelesen? */
		listFeatures.addAll(model.getConcreteFeatures());
		Feature fromFeature = model.getFeature(listFeatures
				.get(fromFeatureID).getName());

		/* Liste einer Menge von Zielfeatures */
		ArrayList<Set<Feature>> toFeaturesList = new ArrayList<Set<Feature>>();
		for (int toFeatureID : toFeatureIDs) {
			Feature toFeature = model.getFeature(listFeatures.get(toFeatureID).getName());
			HashSet<Feature> toFeatureSet = new HashSet<Feature>();
			toFeatureSet.add(toFeature);
			toFeaturesList.add(toFeatureSet);
		}

		try {
			/* alle Features optional */
			if (model.mayBeMissing(null, toFeaturesList)) {	
				StringBuilder sb = new StringBuilder();
				sb.append(toFeatureIDs.size());
				sb.append(" optionale Ziele ");
				sb.append("(es kann eine valide Auswahl geben, "
						+ "in der alle diese Ziele nicht vorhanden sind):\n");					
				sb.append(fromFeature.getName());
				sb.append(" zielt auf ");
				sb.append(targetStructure);
				sb.append(" folgender Features:\n");
				for (int toFeatureID : toFeatureIDs) {
					sb.append(model.getFeature(listFeatures.get(toFeatureID).getName()).getName());
					sb.append(":\t");
					String decl = mapDecls.get(toFeatureID);
					sb.append(decl);
					sb.append("\n");
				}
				if(isTypeAccess) {
					typeError(sb.toString());
				} else {
					error(sb.toString());
				}
			}				
		} catch (TimeoutException e) {
			e.printStackTrace();
		}
	}

	public void ASTNode.splTypeCheck() {
		
	}

	public void VarAccess.splTypeCheck() {
		HashMap<Integer, String> mapDecls = new HashMap<Integer, String>();

		/* Ist der Variablenzugriff ein Feldzugriff? */
		if (isFieldAccess()) {			
			int fromFeatureID = featureID();
			SimpleSet decls = decls();
			/* nur ein Zielfeature */
			if (decls.size() == 1) {
				BodyDecl var = (BodyDecl) decl();
				int toFeatureID = var.featureID();
				addSplErrors(fromFeatureID, toFeatureID, "das Feld", 
						var.toString(), false);
			/* mehrere Zielfeatures */
			} else {
				ArrayList<Integer> toFeatureIDs = new ArrayList<Integer>();
				for(Iterator iter = decls.iterator(); iter.hasNext(); ){
					BodyDecl var = (BodyDecl) iter.next();
					toFeatureIDs.add(var.featureID());
					String decl = var.toString();
					String declFirstLine = ( decl.indexOf("\n") == -1
							? decl 
									: decl.substring(0, decl.indexOf("\n")) + " ... }" );
					mapDecls.put(var.featureID(), declFirstLine);
				}
				addSplErrors(fromFeatureID, toFeatureIDs, "das Feld", 
						mapDecls, false);
			}
		}    
	}

	public void MethodAccess.splTypeCheck() {
		HashMap<Integer, String> mapDecls = new HashMap<Integer, String>();

		int fromFeatureID = featureID();
		ArrayList<MethodDecl> methodDecls = new ArrayList<MethodDecl>();
		/* ermittle im Typ alle Methoden mit gleicher Signatur */
		for(BodyDecl bd : decl().hostType().getBodyDecls()) {
			if (bd instanceof MethodDecl) {
				if(((MethodDecl) bd).signature().equals(decl().signature())) {
					methodDecls.add((MethodDecl) bd);
				}
			}
		}
		/* nur eine Methode mit dieser Signatur */
		if (methodDecls.size() == 1) {
			MethodDecl var = (MethodDecl) decl();
			int toFeatureID = var.featureID();
			addSplErrors(fromFeatureID, toFeatureID, "die Methode", 
					var.toString(), false);
		/* mehrere Methoden mit dieser Signatur */
		} else {
			ArrayList<Integer> toFeatureIDs = new ArrayList<Integer>();
			for(Iterator<MethodDecl> iter = methodDecls.iterator(); iter.hasNext(); ){
				MethodDecl var = iter.next();
				toFeatureIDs.add(var.featureID());
				String decl = var.toString();
				String declFirstLine = ( decl.indexOf("\n") == -1
						? decl 
								: decl.substring(0, decl.indexOf("\n")) + " ... }" );
				mapDecls.put(var.featureID(), declFirstLine);
			}
			addSplErrors(fromFeatureID, toFeatureIDs, "die Methode", 
					mapDecls, false);
		}
	}
	
	public void TypeAccess.splTypeCheck() {		
		/* try, catch, throws
		 * Generics
		 * Cast
		 * Constructor
		 * innere Klassen
		 * Methodenredefinition, anonyme Methoden */

		/* collect all TypeAccesses: source feature, type, target feature(s) */
		int fromFeatureID = featureID();
		
		HashMap<String, ArrayList<Integer>> typeDeclFeatures = typeAccesses.get(fromFeatureID);
		if(typeDeclFeatures == null) {
			typeDeclFeatures = new HashMap<String, ArrayList<Integer>>();
		}
		
		ArrayList<Integer> toFeatureIDs = new ArrayList<Integer>();

		/* extends (?, weglassen): Vorhandensein von mehreren 
		 * Default-Constructoren */
		ArrayList<ConstructorDecl> constructorDecls = new ArrayList<ConstructorDecl>();
		for(BodyDecl bd : decl().hostType().getBodyDecls()) {
			if (bd instanceof ConstructorDecl) {
				if (((ConstructorDecl) bd).signature().equals(decl().hostType().name() + "()")) {
					constructorDecls.add((ConstructorDecl) bd);
				}
			}
		}		
		for(Iterator iter = constructorDecls.iterator(); iter.hasNext(); ){
			ConstructorDecl var = (ConstructorDecl) iter.next();
			toFeatureIDs.add(var.featureID());
		}
		/* /extends */
		
		/* implements (?, weglassen), Interface */

		if (!(decl().hostType().featureID() == -1)) {
			String qualifiedName = (decl().hostType().packageName() != "" 
					? decl().hostType().packageName() 
							: "(default package)") 
							+ "." 
							+ decl().hostType().name();
			typeDeclFeatures.put(qualifiedName, toFeatureIDs);
		}		
		typeAccesses.put(fromFeatureID, typeDeclFeatures);
	}
}